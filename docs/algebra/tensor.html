<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>表示的张量积与正交定理</title>
  <style>
    html {
      line-height: 2;
      font-family: “Helvetica Neue”, Helvetica, Arial, “PingFang SC”,
    “Microsoft Yahei”,“Hiragino Sans GB”,“Heiti SC”,“WenQuanYi Micro
    Hei”,sans-serif;;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 1em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}

    figure {
      text-align: center;
    }
    .breadcrumb ul {
        display: flex;
        list-style: none;
    }

    .breadcrumb li::before {
        content: "\00a0/\00a0";
    }

    .breadcrumb li:first-child::before {
        content: "";
    }  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
  <!-- pandoc-eqnos: equation style -->
  <style>
    .eqnos { display: inline-block; position: relative; width: 100%; }
    .eqnos br { display: none; }
    .eqnos-number { position: absolute; right: 0em; top: 50%; line-height: 0; }
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">表示的张量积与正交定理</h1>
</header>
<nav class="breadcrumb">
  <ul>
        <li>代数、模与对称性</li>
        <li>表示的张量积与正交定理</li>
      </ul>
</nav>
<p>在本节中，我们介绍表示空间的张量积的概念。
利用张量积的概念，我们不仅可以证明群表示的若干重要定理，如群表示矩阵的正交定理（以及相应的特征标的正交定理）；
同时表示的张量积也能够用来描述量子力学中相关的对称性性质，特别是量子力学中的维格纳（Wigner）-埃加（Eckart）定理。
在量子力学中，张量积是一个重要而常见的概念。</p>
<h2 id="代数的张量积与模的张量积">代数的张量积与模的张量积</h2>
<p>我们首先给出最一般的张量积的定义。 我们首先回顾线性空间的张量积。
假设<span class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>是<span
class="math inline">\(K\)</span>上的两个有限维线性空间，它们的张量积，记作<span
class="math inline">\(V\otimes W\)</span>，是由<span
class="math inline">\(\{v\otimes w|\forall v\in V, w\in
W\}\)</span>张成的线性空间。 这里的张量积满足对向量加法的分配律和 <span
class="math display">\[\forall \lambda\in K, (\lambda u)\otimes
v=u\otimes(\lambda v)=\lambda(u\otimes v).\]</span> 如果<span
class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>的基底分别为<span
class="math inline">\(\{e_i^V\}\)</span>和<span
class="math inline">\(\{e_i^W\}\)</span>，则<span
class="math inline">\(V\otimes W\)</span>的一组基底为<span
class="math inline">\(\{e_i^V\otimes e_j^W\}\)</span>。</p>
<p>接下来，我们引入代数之间的张量积。 假设<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>是<span
class="math inline">\(K\)</span>上的两个有限维代数。
由于代数首先是线性空间，我们首先构造二者作为线性空间的张量积<span
class="math inline">\(A\otimes B\)</span>，并赋予其如下的乘法结构：
<span class="math display">\[(a\otimes b)\cdot (a&#39;\otimes b&#39;)
=aa&#39;\otimes bb&#39;.\]</span> 容易验证，<span
class="math inline">\(A\otimes B\)</span>在该乘法下也构成<span
class="math inline">\(K\)</span>上的一个代数。
我们称具有上述代数结构的<span class="math inline">\(A\otimes
B\)</span>为这两个代数之间的张量积。</p>
<p>接下来，我们考虑<span
class="math inline">\(K\)</span>上的两个有限维代数<span
class="math inline">\(A\)</span>和<span
class="math inline">\(B\)</span>，假设<span
class="math inline">\(V\)</span>是一个<span
class="math inline">\(A\)</span>-模；<span
class="math inline">\(W\)</span>是一个<span
class="math inline">\(B\)</span>-模。 我们可以构造<span
class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>作为线性空间的张量积<span
class="math inline">\(V\otimes W\)</span>。 利用如下乘法，<span
class="math inline">\(V\otimes W\)</span>可以看成一个<span
class="math inline">\(A\otimes B\)</span>-模： <span
class="math display">\[\forall a\in A, b\in B, v\in V, w\in W:
(a\otimes b)\cdot(v\otimes w)
=av\otimes bw.
\]</span> 我们称这样的<span class="math inline">\(A\otimes
B\)</span>-模<span class="math inline">\(V\otimes
W\)</span>为两个模<span class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>的张量积。</p>
<p>特别地，假设<span class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>是两个<span
class="math inline">\(A\)</span>-模（即在上述定义中取<span
class="math inline">\(B=A\)</span>的特殊情形），上面定义的<span
class="math inline">\(V\otimes W\)</span>是一个<span
class="math inline">\(A\otimes A\)</span>-模，而不是我们想要的<span
class="math inline">\(A\)</span>-模。
事实上，对于一个一般的（有限维）代数<span
class="math inline">\(A\)</span>，<span class="math inline">\(V\otimes
W\)</span>不一定是一个<span class="math inline">\(A\)</span>-模。
为了赋予<span class="math inline">\(V\otimes W\)</span>一个<span
class="math inline">\(A\)</span>-模的结构（即赋予它一个<span
class="math inline">\(A\)</span>的作用），我们需要找到一个代数同态<span
class="math inline">\(\Delta: A\rightarrow A\otimes A\)</span>。
这样一个代数同态<span
class="math inline">\(\Delta\)</span>往往被形象地称为一个“上乘法”（comultiplication）。
如果能在<span class="math inline">\(A\)</span>上找到一个上乘法<span
class="math inline">\(\Delta\)</span>，就可以赋予<span
class="math inline">\(V\otimes W\)</span>一个<span
class="math inline">\(A\)</span>-模的结构： <span
class="math display">\[a\cdot (v\otimes w)=\Delta(a)\cdot(v\otimes w).
\]</span> 此时，对于任意两个<span
class="math inline">\(A\)</span>-模<span
class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>，其张量积<span
class="math inline">\(V\otimes W\)</span>也是一个<span
class="math inline">\(A\)</span>-模。</p>
<h3 id="群表示的张量积">群表示的张量积</h3>
<p>对于域<span class="math inline">\(K\)</span>上的群代数<span
class="math inline">\(A=K[G]\)</span>，我们可以定义如下的上乘法：
<span id="eq:tensor:KG-comul" class="eqnos"><span
class="math display">\[\forall g\in G, \Delta(g)=g\otimes g.
\]</span><span class="eqnos-number">(1)</span></span> 并给出群代数<span
class="math inline">\(A\)</span>的模（即<span
class="math inline">\(G\)</span>的表示）之间的张量积，其中群作用如下：
<span id="eq:tensor:diag-act" class="eqnos"><span
class="math display">\[g\cdot(v\otimes w)=gv\otimes gw.
\]</span><span class="eqnos-number">(2)</span></span>
这样的群作用又被称为对角作用（diagonal action）。
在这样的上乘法下，两个群的表示的张量积还是该群的表示。</p>
<p>对于投影群代数<span class="math inline">\(\mathbb
C[G]^\omega\)</span>，(<a
href="#eq:tensor:KG-comul">1</a>)给出来的并不是<span
class="math inline">\(\mathbb C[G]^\omega\)</span>上的一个上乘法。
事实上，如果<span class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>分别是<span
class="math inline">\(\mathbb C[G]^\alpha\)</span>和<span
class="math inline">\(\mathbb C[G]^\beta\)</span>的两个模（表示），(<a
href="#eq:tensor:diag-act">2</a>)式中给出的对角作用会给出<span
class="math inline">\(\alpha+\beta\)</span>对应的投影表示。 因此，<span
class="math inline">\(V\otimes
W\)</span>（在上面的对角作用下）是一个<span
class="math inline">\(\mathbb C[G]^{\alpha+\beta}\)</span>-模。
感兴趣的读者可以自行验证，(<a href="#eq:tensor:KG-comul">1</a>)式是<span
class="math inline">\(\mathbb C[G]^{\alpha+\beta}\rightarrow\mathbb
C[G]^\alpha\otimes\mathbb C[G]^\beta\)</span>的代数同态。</p>
<h2 id="对偶表示">对偶表示</h2>
<h3 id="代数表示的对偶表示">代数表示的对偶表示</h3>
<p>接下来，我们引入对偶表示的概念。
与张量积类似，我们先考虑最一般的代数，再对群代数构造性质更好的对偶表示。
对于一个一般的代数<span class="math inline">\(A\)</span>，假设<span
class="math inline">\(V\)</span>是<span
class="math inline">\(A\)</span>-模，即<span
class="math inline">\(A\)</span>的表示。 作为一个线性空间，我们考虑<span
class="math inline">\(V\)</span>的对偶空间<span
class="math inline">\(V^*=\hom(V, K)\)</span>，即由<span
class="math inline">\(V\)</span>到域<span
class="math inline">\(K\)</span>的线性映射构成的线性空间。
我们可以为<span
class="math inline">\(V^\ast\)</span>引入如下的代数作用（即与<span
class="math inline">\(A\)</span>中的元素之间的乘法）：
<span id="eq:tensor:dual-action" class="eqnos"><span
class="math display">\[\forall f\in V^*, \forall a\in A, (f\cdot
a)(v)=f(a\cdot v).
\]</span><span class="eqnos-number">(3)</span></span>
细心的读者会发现，上面定义的<span
class="math inline">\(V^*\)</span>与<span
class="math inline">\(A\)</span>之间的乘法与我们前面讨论的代数在线性空间上的作用不同：<span
class="math inline">\(A\)</span>是从右边，而非左边乘到<span
class="math inline">\(V^\ast\)</span>上去的。
因此，数学上称具有这样定义的代数作用的<span
class="math inline">\(V^*\)</span>为<span
class="math inline">\(A\)</span>的一个右模（right
module）；相应地，我们之前讨论的<span
class="math inline">\(A\)</span>模严格意义上说都是<span
class="math inline">\(A\)</span>的左模（left module）。
当然，从右边还是左边乘上去只是一个符号的约定；我们当然也可以将<span
class="math inline">\(f\cdot a\)</span>改写成一个左作用<span
class="math inline">\(a\star f\)</span>。
但是这样“硬”写出来的左乘并不满足左模的要求：对于<span
class="math inline">\(A\)</span>中两个元素<span
class="math inline">\(a,b\in A\)</span>，二者在<span
class="math inline">\(f\)</span>上相继作用得到的是<span
class="math inline">\(a\star(b\star f)=(f\cdot b)\cdot
a=f\cdot(ba)=(ba)\star f\)</span>而不是<span
class="math inline">\((ab)\star f\)</span>。 因此，一般地，<span
class="math inline">\(A\)</span>的一个右模不是<span
class="math inline">\(A\)</span>的左模。 事实上，对于代数<span
class="math inline">\(A\)</span>，我们可以定义它的反向代数（opposite
algebra）<span
class="math inline">\(A^{\mathrm{op}}\)</span>：它作为一个线性空间和<span
class="math inline">\(A\)</span>同构，但是其上面的乘法（我们将其记作<span
class="math inline">\(\star\)</span>）是反过来的： <span
class="math display">\[a^{\mathrm{op}}\cdot b^{\mathrm{op}}=b\cdot
a.\]</span> 在这个构造下，<span
class="math inline">\(A\)</span>的右模是<span
class="math inline">\(A^{\mathrm{op}}\)</span>的左模。
因此，我们定义的对偶表示<span
class="math inline">\(V^\ast\)</span>也是<span
class="math inline">\(A^{\mathrm{op}}\)</span>的左模。</p>
<p>在选定基底之后，上面抽象的对偶概念可以表述成矩阵的转置。
在取定基底之后，如果我们将<span
class="math inline">\(V\)</span>中的向量写成列向量，那么<span
class="math inline">\(V^*\)</span>中的元素可以写成行向量。 相应地，(<a
href="#eq:tensor:dual-action">3</a>)中的表示矩阵可以写成<span
class="math inline">\(f^T\phi(a)v\)</span>，其中<span
class="math inline">\(f\)</span>是一个列向量；<span
class="math inline">\(f^T\)</span>是一个行向量。 <span
class="math inline">\(A\)</span>在<span
class="math inline">\(f\)</span>上的作用可以通过转置的方式写成 <span
class="math display">\[(f^T\phi(A))^T=\phi(A)^Tf.\]</span>
因此，对偶表示<span
class="math inline">\(V^*\)</span>可以看成表示矩阵的转置矩阵<span
class="math inline">\(\phi(a)^T\)</span>构成的表示。
由于转置操作满足<span
class="math inline">\(\phi(a)^T\phi(b)^T=(\phi(b)\phi(a))^T=\phi(ba)^T\)</span>，<span
class="math inline">\(V^*\)</span>确实是<span
class="math inline">\(A^{\mathrm{op}}\)</span>的表示。
这里需要注意的是，即使对于复代数，上面定义的对偶表示的表示矩阵也是原表示的转置<span
class="math inline">\(\phi(a)^T\)</span>，而不是厄米转置<span
class="math inline">\(\phi(a)^\dagger\)</span>。</p>
<p>与上面讨论的张量积类似，对于一个一般的代数<span
class="math inline">\(A\)</span>，它的表示<span
class="math inline">\(V\)</span>的对偶表示<span
class="math inline">\(V^*\)</span>也不是<span
class="math inline">\(A\)</span>的表示，而是<span
class="math inline">\(A^{\mathrm{op}}\)</span>的表示。 为了让<span
class="math inline">\(V^*\)</span>也成为<span
class="math inline">\(A\)</span>的表示，我们需要<span
class="math inline">\(A\)</span>到<span
class="math inline">\(A^{\mathrm{op}}\)</span>的一个同态映射<span
class="math inline">\(S\)</span>，即<span
class="math inline">\(A\)</span>到自身的一个反同态映射<span
class="math inline">\(S\)</span>，称为一个对极（antipole）映射。
这个映射<span class="math inline">\(S\)</span>满足<span
class="math inline">\(S(ab)=S(b)S(a)\)</span>。 利用<span
class="math inline">\(S\)</span>，我们可以构造<span
class="math inline">\(A\)</span>在<span
class="math inline">\(V^*\)</span>上的作用：
<span id="eq:tensor:antipole" class="eqnos"><span
class="math display">\[a\cdot v:=S(a)\star v=v\cdot S(a).
\]</span><span class="eqnos-number">(4)</span></span> 从而赋予<span
class="math inline">\(V^*\)</span>一个（左）<span
class="math inline">\(A\)</span>-模的结构。</p>
<h3 id="群表示的对偶表示">群表示的对偶表示</h3>
<p>对于域<span class="math inline">\(K\)</span>上的群代数<span
class="math inline">\(A=K[G]\)</span>，我们可以定义如下的对极映射<span
class="math inline">\(S\)</span>： <span
class="math display">\[S(g)=g^{-1},\forall g\in G.\]</span>
注意：在上式中，我们对<span
class="math inline">\(A\)</span>的一组线性独立的基底，即任意的群元素<span
class="math inline">\(g\)</span>定义了<span
class="math inline">\(S\)</span>；由于<span
class="math inline">\(S\)</span>也是一个线性映射，上述定义可以被线性地扩展到整个空间<span
class="math inline">\(A\)</span>上。 容易验证，这样定义的<span
class="math inline">\(S\)</span>满足(<a
href="#eq:tensor:antipole">4</a>)式的要求，构成一个对极映射。</p>
<p>利用如上定义的对极映射，群<span
class="math inline">\(G\)</span>的对偶表示也是<span
class="math inline">\(G\)</span>的表示。 其表示矩阵为 <span
class="math display">\[\phi_{V^\ast} (g)=\phi_V(S(g))^T
=\phi_V(g^{-1})^T=\left[\phi_V(g)^{-1}\right]^T.\]</span> 如果<span
class="math inline">\(V\)</span>是幺正表示，<span
class="math inline">\(\phi_V(g)^{-1}=\phi_V(g)^\dagger\)</span>，因此其对偶表示矩阵为
<span class="math display">\[\phi_{V^\ast}(g)=\phi_V(g)^\ast,\]</span>
即为原表示矩阵的复共轭。</p>
<h2 id="群表示的正交定理">群表示的正交定理</h2>
<p>为了让读者体会到张量积和对偶这两个概念的重要性，我们利用前面介绍的张量积和对偶表示的概念，证明第??章中介绍（但未证明的）群表示特征标之间的正交定理。</p>
<h3 id="特征标正交定理的证明">特征标正交定理的证明</h3>
<p>为了读者方便，我们首先回顾一下群表示特征标之间的正交定理。 假设<span
class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>为有限群<span
class="math inline">\(G\)</span>的两个不可约复表示，其特征标分别为<span
class="math inline">\(\chi_V\)</span>和<span
class="math inline">\(\chi_W\)</span>。 它们满足如下的正交定理：
<span id="eq:tensor:chi-orth" class="eqnos"><span
class="math display">\[\frac1{|G|}\sum_{g\in
G}\chi_V^\ast(g)\chi_W(g)=\delta_{VW},
\]</span><span class="eqnos-number">(5)</span></span> 其中<span
class="math inline">\(\delta_{VW}\)</span>表示<span
class="math inline">\(V\)</span>和<span
class="math inline">\(W\)</span>是否为同一个不可约表示：当二者相同（等价）时<span
class="math inline">\(\delta_{VW}=1\)</span>，否则<span
class="math inline">\(\delta_{VW}=0\)</span>。</p>
<p>为证明这一点，我们首先将等式左边用表示的张量积和对偶表达出来。
容易看出，<span class="math inline">\(\chi_V(g)\chi_W(g)=\chi_{V\otimes
W}(g)\)</span>；以及<span
class="math inline">\(\chi_V^\ast(g)=\chi_{V^\ast}(g)\)</span>。
因此，(<a href="#eq:tensor:chi-orth">5</a>)式左边可以写成 <span
class="math display">\[\text{LHS}=\frac1{|G|}\sum_{g\in
G}\chi_{V^\ast\otimes W}(g)
=\mathrm{tr}\,\left(\frac1{|G|}\sum_{g\in G}g\right)_{V^\ast\otimes
W}.\]</span> 我们定义投影算符 <span id="eq:tensor:P" class="eqnos"><span
class="math display">\[P := \frac1{|G|}\sum_{g\in G}g\in Z(\mathbb
C[G]).
\]</span><span class="eqnos-number">(6)</span></span> (<a
href="#eq:tensor:chi-orth">5</a>)式左边可以写成 <span
class="math display">\[\text{LHS}=\mathrm{tr}\,P_{V^\ast\otimes
W},\]</span> 其中<span class="math inline">\(P_{V^\ast\otimes
W}\)</span>表示<span class="math inline">\(P\)</span>在模<span
class="math inline">\(V^\ast\otimes W\)</span>上的表示矩阵。</p>
<p>根据舒尔引理，<span
class="math inline">\(P\)</span>在一个表示上是分块对角的：它在每个不可约表示上都是一个标量；且在不同不可约表示之间为零。
此外，容易验证<span class="math inline">\(P^2=P\)</span>是一个投影算符。
因此，<span
class="math inline">\(P\)</span>在每个不可约表示上的标量值都是0或者1.
进一步地，可以证明<span
class="math inline">\(P\)</span>是到平凡表示的投影算符：它在平凡表示（记作<span
class="math inline">\(V_1\simeq\mathbb
C\)</span>）上是1；在其它表示上是零。 因此，<span
class="math inline">\(\mathrm{tr}\,P_{V^\ast\otimes
W}\)</span>就等于平凡表示在<span class="math inline">\(V^\ast\otimes
W\)</span>的不可约分解中出现的重数： <span
class="math display">\[\text{LHS}=\dim\mathrm{Hom}_A(\mathbb C,
V^\ast\otimes W).\]</span>
张量积和对偶表示有个很有意思的性质：它可以在线性映射<span
class="math inline">\(\mathrm{Hom}_A\)</span>的计算中移动位置，如：
<span class="math display">\[\mathrm{Hom}_A(\mathbb C, V^\ast\otimes W)
\simeq\mathrm{Hom}_A(V, W).\]</span> 而根据舒尔引理，当<span
class="math inline">\(V\simeq W\)</span>时，<span
class="math inline">\(\mathrm{Hom}_A(V, W)\simeq\mathbb
C\)</span>，其维度为1； 当二者不等价时，<span
class="math inline">\(\mathrm{Hom}_A(V, W)=0\)</span>，其维度为0。
因此，<span class="math inline">\(\text{LHS}=\dim\mathrm{Hom}_A(\mathbb
C, V^\ast\otimes W)=\delta_{VW}\)</span>，这完成了对(<a
href="#eq:tensor:chi-orth">5</a>)式的证明。</p>
<p>此外，<span class="math inline">\(\dim\mathrm{Hom}_A(\mathbb C,
V^\ast\otimes W)=\delta_{VW}\)</span>也指出，平凡表示<span
class="math inline">\(\mathbb C\)</span>在<span
class="math inline">\(V^\ast\otimes
V\)</span>中出现且仅出现一次；而当<span
class="math inline">\(W\)</span>与<span
class="math inline">\(V\)</span>不等价时，<span
class="math inline">\(V^\ast\otimes W\)</span>中并不包含平凡表示。</p>
<h3 id="特征标正交性的推论">特征标正交性的推论</h3>
<p>从(<a
href="#eq:tensor:chi-orth">5</a>)式中的正交关系出发，可以直接得到一个重要的推论：有限群的特征标表的每行和每列都是正交的。</p>
<p>在第??章中，我们介绍过有限群的特征标表的概念。
特征标表的每行对应一个不可约表示<span
class="math inline">\(V\)</span>，而每列对应有限群<span
class="math inline">\(G\)</span>的一个共轭类（这是因为两个共轭元素<span
class="math inline">\(g\)</span>和<span
class="math inline">\({}^hg=hgh^{-1}\)</span>的特征标总是相等的：<span
class="math inline">\(\chi_V(g)=\chi_V({}^hg)\)</span>）。
在上一节中，我们利用群代数的Artin-Wedderburn分解证明了不可约表示的个数等于共轭类的个数。
因此，特征标表的行数总是等于其列数，即该表构成一个方阵。 在(<a
href="#eq:tensor:chi-orth">5</a>)式基础上，我们可以恰当地选择该方阵的归一化系数，将其变为一个正交矩阵。
具体地，假设群<span class="math inline">\(G\)</span>共有<span
class="math inline">\(r\)</span>个共轭类和<span
class="math inline">\(r\)</span>个不可约表示。 我们将共轭类标记为<span
class="math inline">\([g_i]\)</span>、不可约表示标记为<span
class="math inline">\(V_i\)</span>，其中<span
class="math inline">\(i=1,2,\ldots, r\)</span>。 这里我们一般假设<span
class="math inline">\(g_1=1\)</span>为单位元；<span
class="math inline">\(V_1\)</span>为群的平凡表示；但除此之外，一般来讲，二者没有什么标准的标记方式，它们之间也没有什么典范的对应关系。
由此，我们可以将特征标表中的元素写成一个矩阵的矩阵元：<span
class="math inline">\(\chi_{ij}=\chi_{V_i}(g_j)\)</span>。
为了将特征标之间的正交关系转化为矩阵的正交关系，我们定义如下重新归一化的矩阵<span
class="math inline">\(X\)</span>，其矩阵元为： <span
class="math display">\[X_{ij}=\sqrt{\frac{|[g_j]|}{|G|}}\chi_{ij}=\sqrt{\frac{|[g_j]|}{|G|}}\chi_{V_i}(g_j).\]</span>
根据(<a href="#eq:tensor:chi-orth">5</a>)式不难得到，<span
class="math inline">\(X^\dagger X=I\)</span>，即<span
class="math inline">\(X\)</span>为幺正矩阵。 因此，<span
class="math inline">\(X\)</span>的所有行向量和列向量分别构成一组正交归一的向量。
它的行向量之间的正交归一性就是(<a href="#eq:tensor:chi-orth">5</a>)式；
而它的列向量之间的正交归一性则给出如下的特征标正交定理（又称特征标第二正交定理）：
<span
class="math display">\[\frac{\left|[g]\right|}{G}\sum_{i=1}^r\chi_{V_i}(g)^\ast\chi_{V_i}(h)=\delta_{[g],
[h]},\]</span> 其中<span class="math inline">\(\delta_{[g],
[h]}\)</span>当<span class="math inline">\(g\)</span>和<span
class="math inline">\(h\)</span>同属一个共轭类时为1，否则为0。</p>
<h3 id="群表示矩阵元的正交定理">群表示矩阵元的正交定理</h3>
<p>在本节中，我们利用前面介绍的张量积和对偶表示的概念，证明群表示矩阵元的正交定理。</p>
<p>假设有限群<span class="math inline">\(G\)</span>共有<span
class="math inline">\(r\)</span>种不等价的不可约表示，分别记作<span
class="math inline">\(V_1,\ldots,V_r\)</span>。 我们在每个表示空间<span
class="math inline">\(V_i\)</span>中取定一组正交归一的基底<span
class="math inline">\(\{|i;\alpha\rangle\}\)</span>，从而将表示<span
class="math inline">\(\phi_{V_i}(g)\)</span>写成矩阵的形式：
我们将相应的矩阵元记为 <span
class="math display">\[\phi^i_{\alpha\beta}(g)=\langle
i;\alpha|\phi_{V_i}(g)|i;\beta\rangle.\]</span>
我们将要证明如下的正交定理：
<span id="eq:tensor:mat-elem-orth" class="eqnos"><span
class="math display">\[\frac1{|G|}\sum_{g\in
G}\phi^i_{\alpha\beta}(g)^\ast\phi^j_{\alpha&#39;\beta&#39;}(g)=\frac1{\dim
V_i}\delta^{ij}\delta_{\alpha\alpha&#39;}\delta_{\beta\beta&#39;}.
\]</span><span class="eqnos-number">(7)</span></span> </p>
<p>我们注意到等式左边可以写成<span
class="math inline">\(g\)</span>在表示<span
class="math inline">\(V_i^\ast\otimes V_j\)</span>上面的表示矩阵：
对于<span class="math inline">\(V_i^\ast\otimes
V_j\)</span>，我们可以取它的基底为<span
class="math inline">\(\overline{|i;\alpha\rangle}\otimes|j;\alpha&#39;\rangle\)</span>，其中<span
class="math inline">\(\overline{|i;\alpha\rangle}=(\langle
i;\alpha|)^T\)</span>是对偶空间<span
class="math inline">\(V_i^\ast\)</span>的一组正交归一的基底，这里为了记号清晰起见，我们还是将对偶空间的元素通过转置写成右矢的形式。
这样，等式左边求和号里的矩阵元可以写成： <span
class="math display">\[\phi^i_{\alpha\beta}(g)^\ast\phi^j_{\alpha&#39;\beta&#39;}(g)
=\overline{\langle i;\alpha|}\phi_{V_i}(g)^*\overline{|j;\beta\rangle}
\cdot\langle i;\alpha&#39;|\phi_{V_i}(g)|i;\beta&#39;\rangle
=\overline{\langle i;\alpha|}\otimes\langle
j;\alpha&#39;|\phi_{V_i^\ast\otimes V_j}(g)\overline{|i;\beta\rangle}
\otimes|j;\beta&#39;\rangle.\]</span> 因此，(<a
href="#eq:tensor:mat-elem-orth">7</a>)式左边可以表示成(<a
href="#eq:tensor:P">6</a>)式中定义的投影算符<span
class="math inline">\(P\)</span>的矩阵元： <span
class="math display">\[\text{LHS}=\overline{\langle
i;\alpha|}\otimes\langle j;\alpha&#39;|\phi_{V_i^\ast\otimes
V_j}(P)\overline{|i;\beta\rangle}
\otimes|j;\beta&#39;\rangle.\]</span></p>
<p>根据前面的讨论，<span class="math inline">\(P\)</span>是从<span
class="math inline">\(V_i^\ast\otimes V_j\)</span>到平凡表示<span
class="math inline">\(\mathbb C\)</span>的投影算符。 根据<span
class="math inline">\(\mathrm{Hom}_A(V_i^\ast\otimes V_j,\mathbb
C)\simeq\mathrm{Hom}_A(V_j, V_i)\)</span>的同构关系，不难得到<span
class="math inline">\(V_i^\ast\otimes V_j\)</span>中平凡表示为<span
class="math inline">\(\sum_\alpha\overline{|i;\alpha\rangle}\otimes|j;\alpha\rangle\)</span>张成的一维子空间。
因此，<span class="math inline">\(P\)</span>在<span
class="math inline">\(V_i^*\otimes V_j\)</span>的矩阵元为 <span
class="math display">\[\overline{\langle i;\alpha|}\otimes\langle
j;\alpha&#39;|
\phi_{V_i^\ast\otimes V_j}(P)\overline{|i;\beta\rangle}
\otimes|j;\beta&#39;\rangle=\delta_{\alpha\alpha&#39;}\delta_{\beta\beta&#39;}.\]</span>
这样就证明了(??)式。</p>
<p>事实上，在(??)式中令<span
class="math inline">\(\beta=\alpha&#39;\)</span>，并对<span
class="math inline">\(\alpha\)</span>、<span
class="math inline">\(\alpha&#39;\)</span>和<span
class="math inline">\(\beta&#39;\)</span>求和，即可得到特征标的正交定理。</p>
<h3 id="不可约表示的投影算符">不可约表示的投影算符</h3>
<p>在上面的推导中我们看到，(<a href="#eq:tensor:P">6</a>)式中定义的<span
class="math inline">\(P\)</span>算符是到平凡表示的投影算符。
利用特征标，我们可以推导到任一不可约表示的投影算符。
我们沿用本节中的记号，将有限群<span
class="math inline">\(G\)</span>的不可约表示记作<span
class="math inline">\(V_i\)</span>，<span class="math inline">\(1\leq
i\leq r\)</span>。 一般地，假设<span
class="math inline">\(V\)</span>是<span
class="math inline">\(G\)</span>的一个表示，那么<span
class="math inline">\(V\)</span>中包含<span
class="math inline">\(V_i\)</span>的重数可以利用特征标计算得到： 假设
<span class="math display">\[V=\bigoplus_{i=1}^rm_iV_i,\]</span>
根据特征标之间的正交关系，我们可以得到 <span
class="math display">\[m_i=\frac1{|G|}\sum_g\chi_{V_i}(g)^*\chi_V(g).\]</span>
根据上式，我们得到 <span
class="math display">\[m_i=\mathrm{tr}\,\left(\frac1{G}\sum_g\chi_{V_i}(g)\phi_V(g)\right).\]</span>
这启发我们定义如下的投影算符： <span
class="math display">\[P_i=\frac1{G}\sum_g\chi_{V_i}(g)g.
\]</span> 特别地，(<a href="#eq:tensor:P">6</a>)式中定义的<span
class="math inline">\(P\)</span>就是平凡表示<span
class="math inline">\(V_1\)</span>对应的投影算符<span
class="math inline">\(P_1\)</span>。 容易验证，<span
class="math inline">\(P_i\)</span>是相互正交的投影算符：<span
class="math inline">\(P_i^2=P_i\)</span>且当<span
class="math inline">\(i\neq j\)</span>时<span
class="math inline">\(P_iP_j=0\)</span>。 利用群元素的重排定理和<span
class="math inline">\(\chi(g)=\chi({}^hg)\)</span>的关系不难验证，<span
class="math inline">\(P_i\)</span>与群元素对易，即<span
class="math inline">\(P_i\in Z(\mathbb C[G])\)</span>。 这表明<span
class="math inline">\(P_i\)</span>作用在一个<span
class="math inline">\(A\)</span>-模上一定给出一个模同态。
根据舒尔引理，<span
class="math inline">\(P_i\)</span>具有分块对角的形式：在每个不可约表示上它都是常数，而在两个不等价的不可约表示之间为零。
利用特征标的正交归一关系，不难验证<span
class="math inline">\(P_i\)</span>就是到<span
class="math inline">\(V_i\)</span>的投影算符。</p>
<p>例：利用投影算符，我们可以从有限群<span
class="math inline">\(G\)</span>的不可约表示计算其Artin-Wedderburn分解中对应的子代数。</p>
<h2
id="投影表示的张量积对偶与正交性">投影表示的张量积、对偶与正交性*</h2>
<h2
id="表示的张量积在量子力学中的应用">表示的张量积在量子力学中的应用</h2>
<p>量子态之间的张量积是在量子力学中经常出现的概念。</p>
<h3 id="wigner-eckart定理">Wigner-Eckart定理</h3>
<p>在量子力学中，我们经常需要计算某个算符的矩阵元：<span
class="math inline">\(\langle\psi|\hat O|\phi\rangle.\)</span>
假设系统的对称群为<span
class="math inline">\(G\)</span>，我们可将左右两边的量子态和中间的算符都分解到群的不可约表示上。
因此，我们需要计算如下的矩阵元： <span class="math display">\[\langle
i;\alpha|\hat O^j_\beta|k;\gamma\rangle,\]</span> 其中<span
class="math inline">\(i, j, k\)</span>标记了三个不可约表示<span
class="math inline">\(V_i, V_j, V_k\)</span>；而<span
class="math inline">\(\alpha,\beta,\gamma\)</span>标记了三个不可约表示空间的基底。</p>
<p>根据前面对表示张量积和对偶表示的讨论，我们可以将上面的矩阵元组成的矩阵看成是从<span
class="math inline">\(V_j\otimes V_k\)</span>到<span
class="math inline">\(V_i\)</span>的<span
class="math inline">\(G\)</span>-不变的映射： <span
class="math display">\[f: \hat
O^j_\beta|k;\gamma\rangle\mapsto\sum_{\alpha}\langle i;\alpha|\hat
O^j_\beta|k;\gamma\rangle|i;\alpha\rangle,\quad
f\in\mathrm{Hom}_G(V_j\otimes V_k, V_i).\]</span> 根据Schur引理，<span
class="math inline">\(\mathrm{Hom}_G(V_j\otimes V_k,
V_i)\)</span>具有分块对角的形式。 由于<span
class="math inline">\(V_i\)</span>是不可约表示，这里的分块对角的形式取决于<span
class="math inline">\(V_j\otimes V_k\)</span>中包含多少个<span
class="math inline">\(V_i\)</span>： <span
class="math display">\[V_j\otimes V_k\simeq
N_{jk}^iV_i\oplus\cdots.\]</span></p>
<ol type="1">
<li><p><span class="math inline">\(N_{jk}^i=0\)</span>，即<span
class="math inline">\(V_j\otimes V_k\)</span>的不可约分解中没有<span
class="math inline">\(V_i\)</span>，即<span
class="math inline">\(N_{jk}^i=0\)</span>，则根据Schur引理，<span
class="math inline">\(f=0\)</span>；故<span
class="math inline">\(\langle i;\alpha|\hat
O^j_\beta|k;\gamma\rangle=0\)</span>。</p></li>
<li><p><span class="math inline">\(N_{jk}^i=1\)</span>，即<span
class="math inline">\(V_j\otimes
V_k\)</span>的不可约分解中恰好包含一个<span
class="math inline">\(V_i\)</span>，此时Schur引理断言<span
class="math inline">\(f\)</span>为一个常数。 如果将这个常数记为<span
class="math inline">\(\langle i||\hat O^j||k\rangle\)</span>，则有 <span
class="math display">\[\langle i;\alpha|\hat O^j_\beta|k;\gamma\rangle
=\langle i||\hat O^j||k\rangle\cdot \langle
i;\alpha|(|j\beta\rangle\otimes|k;\gamma\rangle).\]</span>
其中的系数<span class="math inline">\(\langle
i;\alpha|(|j\beta\rangle\otimes|k;\gamma\rangle\)</span>，往往也记作<span
class="math inline">\(\langle
i;\alpha|jk;\beta\gamma\rangle\)</span>，是量子力学中角动量组合的Clebsch-Gordan系数（CG系数）的推广，由此一般也称为有限群的CG系数。</p></li>
<li><p><span class="math inline">\(N_{jk}^i&gt;1\)</span>，即<span
class="math inline">\(V_j\otimes
V_k\)</span>的不可约分解中包含超过一个<span
class="math inline">\(V_i\)</span>。 此时Schur引理只能告诉我们，<span
class="math inline">\(f\)</span>在不同的<span
class="math inline">\(V_i\)</span>子空间上具有分块对角的形式，而每个子空间都具有不同的约化系数<span
class="math inline">\(\langle i||\hat O^j||k\rangle\)</span>和CG系数：
<span class="math display">\[\langle i;\alpha|\hat
O^j_\beta|k;\gamma\rangle
=\sum_\rho\langle i||\hat O^j||k\rangle^{(\rho)}\cdot
\langle
i(\rho);\alpha|(|j;\beta\rangle\otimes|k;\gamma\rangle).\]</span>
这种情况比较复杂，我们下面的讨论以上述第二种情形为主。</p></li>
</ol>
<p>上述结论在文献中被称为Wigner（维格纳）-Eckart（埃伽）定理。</p>
<p>根据对偶关系 <span class="math inline">\(\mathrm{Hom}_G(V_j\otimes
V_k, V_i)\simeq\mathrm{Hom}_G(V_i^\ast\otimes V_j\otimes V_k, \mathbb
C)\)</span>，
我们也可以将CG系数写成三个不可约表示张量积上的一个到平凡表示上的交联映射的系数。
当<span class="math inline">\(N_{jk}^i=1\)</span>时，<span
class="math inline">\(V_i^\ast\otimes V_j\otimes
V_k\)</span>的不可约分解中有且仅有一个平凡表示。 假设<span
class="math inline">\(V_i^\ast\otimes V_j\otimes
V_k\)</span>到该平凡表示的交联映射形如 <span
class="math display">\[|i;\alpha\rangle\otimes |j;\beta\rangle\otimes
|k;\gamma\rangle
\mapsto
\begin{pmatrix}i&amp;j&amp;k\\\alpha&amp;\beta&amp;\gamma\end{pmatrix},\]</span>
则称此处的<span
class="math inline">\(\begin{pmatrix}i&amp;j&amp;k\\\alpha&amp;\beta&amp;\gamma\end{pmatrix}\in\mathbb
C\)</span>为Winger 3j符号（symbol）。 容易验证，CG系数和Wigner
3j符号有如下的关系： <span class="math display">\[\langle
i;\alpha|jk;\beta\gamma\rangle
=\begin{pmatrix}i^\ast&amp;j&amp;k\\\alpha^\ast&amp;\beta&amp;\gamma\end{pmatrix},\]</span>
此处<span class="math inline">\(i^\ast\)</span>代表<span
class="math inline">\(V_i\)</span>的对偶表示；<span
class="math inline">\(\alpha^\ast\)</span>代表相对应的基底。</p>
<h2 id="hopf代数及其表示">Hopf代数及其表示*</h2>
</body>
</html>
